'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function isObject(value) {
  return !!value && typeof value === 'object' && !Array.isArray(value);
}

var Predicate = function () {
  function Predicate(type, defaultValue, bypassFactory) {
    if (bypassFactory === void 0) {
      bypassFactory = false;
    }

    _defineProperty(this, "defaultValue", void 0);

    _defineProperty(this, "schema", void 0);

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "checks", []);

    _defineProperty(this, "defaultValueFactory", void 0);

    _defineProperty(this, "deprecatedMessage", '');

    _defineProperty(this, "errorMessage", '');

    _defineProperty(this, "isNever", false);

    _defineProperty(this, "isNullable", false);

    _defineProperty(this, "isRequired", false);

    _defineProperty(this, "noErrorPrefix", false);

    if (typeof defaultValue === 'function' && !bypassFactory) {
      this.defaultValueFactory = defaultValue;
    } else {
      this.defaultValue = defaultValue;
    }

    this.type = type;
  }

  var _proto = Predicate.prototype;

  _proto.and = function and() {
    var _this = this;

    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(keys.length > 0, 'AND requires a list of field names.');
      this.addCheck(function (path) {
        var _ref, _this$schema;

        var andKeys = [_this.key(path)].concat(keys);
        var struct = (_ref = (_this$schema = _this.schema) === null || _this$schema === void 0 ? void 0 : _this$schema.parentStruct) !== null && _ref !== void 0 ? _ref : {};
        var undefs = andKeys.filter(function (key) {
          return struct[key] === undefined || struct[key] === null;
        });

        if (undefs.length === andKeys.length) {
          return;
        }

        _this.invariant(undefs.length === 0, "All of these fields must be defined: " + andKeys.join(', '));
      });
    }

    return this;
  };

  _proto.cast = function cast(value) {
    return value;
  };

  _proto.custom = function custom(callback) {
    var _this2 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(typeof callback === 'function', 'Custom blueprints require a validation function.');
      this.addCheck(function (path, value) {
        try {
          callback(value, _this2.schema);
        } catch (error) {
          _this2.invariant(false, error.message, path);
        }
      });
    }

    return this;
  };

  _proto.default = function _default() {
    var _ref2, _this$schema2;

    var value = this.defaultValueFactory ? this.defaultValueFactory((_ref2 = (_this$schema2 = this.schema) === null || _this$schema2 === void 0 ? void 0 : _this$schema2.struct) !== null && _ref2 !== void 0 ? _ref2 : {}) : this.defaultValue;

    if (value === null) {
      return null;
    }

    return this.cast(value);
  };

  _proto.deprecate = function deprecate(message) {
    if ("production" !== process.env.NODE_ENV) {
      this.invariant(typeof message === 'string' && !!message, 'A non-empty string is required for deprecated messages.');
    }

    this.deprecatedMessage = message;
    return this;
  };

  _proto.invariant = function invariant(condition, message, path) {
    if (path === void 0) {
      path = '';
    }

    if ("production" !== process.env.NODE_ENV) {
      if (condition) {
        return;
      }

      var _ref3 = this.schema || {},
          filePath = _ref3.filePath,
          schemaName = _ref3.schemaName;

      var error = this.errorMessage || message;
      var prefix = '';

      if (path) {
        if (schemaName) {
          prefix += "Invalid " + schemaName + " field \"" + path + "\"";
        } else {
          prefix += "Invalid field \"" + path + "\"";
        }
      } else if (schemaName) {
        prefix += schemaName;
      }

      if (filePath) {
        prefix += " in " + filePath;
      }

      if (prefix && !this.noErrorPrefix) {
        throw new Error(prefix + ". " + error);
      } else {
        throw new Error(error);
      }
    }
  };

  _proto.message = function message(_message) {
    if ("production" !== process.env.NODE_ENV) {
      this.invariant(typeof _message === 'string' && !!_message, 'A non-empty string is required for custom messages.');
    }

    this.errorMessage = _message;
    return this;
  };

  _proto.never = function never() {
    this.defaultValue = undefined;
    this.isNever = true;
    return this;
  };

  _proto.notNullable = function notNullable() {
    this.isNullable = false;
    return this;
  };

  _proto.nullable = function nullable() {
    this.isNullable = true;
    return this;
  };

  _proto.only = function only() {
    var _this3 = this;

    if ("production" !== process.env.NODE_ENV) {
      var defaultValue = this.default();
      this.invariant(typeof defaultValue === this.type, "Only requires a default " + this.type + " value.");
      this.addCheck(function (path, value) {
        _this3.invariant(value === defaultValue, "Value may only be \"" + String(defaultValue) + "\".", path);
      });
    }

    return this;
  };

  _proto.or = function or() {
    var _this4 = this;

    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys[_key2] = arguments[_key2];
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(keys.length > 0, 'OR requires a list of field names.');
      this.addCheck(function (path) {
        var _ref4, _this4$schema;

        var orKeys = [_this4.key(path)].concat(keys);
        var struct = (_ref4 = (_this4$schema = _this4.schema) === null || _this4$schema === void 0 ? void 0 : _this4$schema.parentStruct) !== null && _ref4 !== void 0 ? _ref4 : {};
        var defs = orKeys.filter(function (key) {
          return typeof struct[key] !== 'undefined' && struct[key] !== null;
        });

        _this4.invariant(defs.length > 0, "At least one of these fields must be defined: " + orKeys.join(', '));
      });
    }

    return this;
  };

  _proto.required = function required(state) {
    if (state === void 0) {
      state = true;
    }

    this.isRequired = state;
    return this;
  };

  _proto.run = function run(initialValue, path, schema) {
    this.schema = schema;
    this.defaultValue = this.default();
    var value = initialValue;

    if (value === undefined) {
      if (!this.isRequired) {
        value = this.defaultValue;
      } else if ("production" !== process.env.NODE_ENV) {
        this.invariant(false, 'Field is required and must be defined.', path);
      }
    } else if ("production" !== process.env.NODE_ENV) {
      if (this.deprecatedMessage) {
        console.info("Field \"" + path + "\" is deprecated. " + this.deprecatedMessage);
      }

      if (this.isNever) {
        this.invariant(false, 'Field should never be used.', path);
      }
    }

    if (value === null) {
      if (this.isNullable) {
        return null;
      }

      if ("production" !== process.env.NODE_ENV) {
        this.invariant(false, 'Null is not allowed.', path);
      }
    } else {
      this.checkType(path, value);
    }

    var finalValue = value;
    this.schema.currentPath = path;
    this.schema.currentValue = finalValue;
    finalValue = this.doRun(finalValue, path);
    finalValue = this.validate(finalValue, path);
    return this.cast(finalValue);
  };

  _proto.typeAlias = function typeAlias() {
    return this.type;
  };

  _proto.validate = function validate(value, path) {
    var _this5 = this;

    if (path === void 0) {
      path = '';
    }

    var nextValue = value;
    this.checkType(path, value);
    this.checks.forEach(function (checker) {
      var result = checker.call(_this5, path, nextValue);

      if (typeof result !== 'undefined') {
        nextValue = result;
      }
    });
    return nextValue;
  };

  _proto.xor = function xor() {
    var _this6 = this;

    for (var _len3 = arguments.length, keys = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      keys[_key3] = arguments[_key3];
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(keys.length > 0, 'XOR requires a list of field names.');
      this.addCheck(function (path) {
        var _ref5, _this6$schema;

        var xorKeys = [_this6.key(path)].concat(keys);
        var struct = (_ref5 = (_this6$schema = _this6.schema) === null || _this6$schema === void 0 ? void 0 : _this6$schema.parentStruct) !== null && _ref5 !== void 0 ? _ref5 : {};
        var defs = xorKeys.filter(function (key) {
          return typeof struct[key] !== 'undefined' && struct[key] !== null;
        });

        _this6.invariant(defs.length === 1, "Only one of these fields may be defined: " + xorKeys.join(', '));
      });
    }

    return this;
  };

  _proto.addCheck = function addCheck(checker) {
    this.checks.push(checker);
    return this;
  };

  _proto.checkType = function checkType(path, value) {
    if ("production" !== process.env.NODE_ENV) {
      switch (this.type) {
        case 'array':
        case 'tuple':
          this.invariant(Array.isArray(value), 'Must be an array.', path);
          break;

        case 'custom':
        case 'instance':
        case 'union':
          break;

        case 'object':
        case 'shape':
          this.invariant(isObject(value), 'Must be a plain object.', path);
          break;

        default:
          this.invariant(typeof value === this.type, "Must be a " + this.type + ".", path);
          break;
      }
    }
  };

  _proto.isOptionalDefault = function isOptionalDefault(value) {
    return !this.isRequired && value === this.default();
  };

  _proto.key = function key(path) {
    var index = path.lastIndexOf('.');
    return index > 0 ? path.slice(index + 1) : path;
  };

  _proto.doRun = function doRun(value, path) {
    return value;
  };

  return Predicate;
}();
function custom(callback, defaultValue) {
  return new Predicate('custom', defaultValue).custom(callback);
}
function func(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }

  return new Predicate('function', defaultValue, true).nullable();
}

function typeOf(value) {
  if (Array.isArray(value)) {
    return value.every(function (item) {
      return typeof item === typeof value[0];
    }) ? 'array' : 'union';
  }

  if (isObject(value)) {
    return value.constructor === Object ? 'object' : 'instance';
  }

  switch (typeof value) {
    case 'boolean':
    case 'function':
    case 'number':
    case 'string':
      return typeof value;

    default:
      return 'unknown';
  }
}

function logUnknown(unknownFields, pathPrefix) {
  var unknownKeys = Object.keys(unknownFields);

  if (unknownKeys.length > 0) {
    var message = pathPrefix ? "Unknown \"" + pathPrefix + "\" fields" : 'Unknown fields';
    throw new Error(message + ": " + unknownKeys.join(', ') + ".");
  }
}

var Schema = function () {
  function Schema(blueprint) {
    _defineProperty(this, "blueprint", void 0);

    _defineProperty(this, "currentPath", '');

    _defineProperty(this, "currentValue", null);

    _defineProperty(this, "filePath", '');

    _defineProperty(this, "initialStruct", {});

    _defineProperty(this, "parentPath", '');

    _defineProperty(this, "parentStruct", {});

    _defineProperty(this, "struct", {});

    _defineProperty(this, "schemaName", '');

    _defineProperty(this, "unknown", false);

    if ("production" !== process.env.NODE_ENV) {
      if (!isObject(blueprint)) {
        throw new TypeError('A schema blueprint is required.');
      }
    }

    this.blueprint = blueprint;
  }

  var _proto = Schema.prototype;

  _proto.allowUnknown = function allowUnknown() {
    this.unknown = true;
    return this;
  };

  _proto.build = function build(struct, pathPrefix) {
    var _this = this;

    if (pathPrefix === void 0) {
      pathPrefix = '';
    }

    if ("production" !== process.env.NODE_ENV) {
      if (!isObject(struct)) {
        throw new TypeError("Schema requires a plain object, found " + typeOf(struct) + ".");
      }
    }

    this.initialStruct = _extends({}, struct);
    this.struct = _extends({}, struct);

    var unknownFields = _extends({}, struct);

    Object.keys(this.blueprint).forEach(function (baseKey) {
      var key = baseKey;
      var value = struct[key];
      var predicate = _this.blueprint[key];
      var path = String(pathPrefix ? pathPrefix + "." + key : key);

      if (predicate instanceof Predicate || isObject(predicate) && predicate.constructor.name.endsWith('Predicate')) {
        _this.parentPath = baseKey;
        _this.parentStruct = _this.initialStruct;
        _this.struct[key] = predicate.run(value, path, _this);
      } else if ("production" !== process.env.NODE_ENV) {
        throw new Error("Unknown blueprint for \"" + path + "\". Must be a predicate.");
      }

      delete unknownFields[key];
    });

    if (this.unknown) {
      Object.assign(this.struct, unknownFields);
    } else if ("production" !== process.env.NODE_ENV) {
      logUnknown(unknownFields, pathPrefix);
    }

    return this.struct;
  };

  _proto.setFile = function setFile(name) {
    this.filePath = name;
    return this;
  };

  _proto.setName = function setName(name) {
    this.schemaName = name;
    return this;
  };

  return Schema;
}();

function optimal(struct, blueprint, options) {
  if (options === void 0) {
    options = {};
  }

  if ("production" !== process.env.NODE_ENV) {
    if (!isObject(options)) {
      throw new TypeError('Optimal options must be a plain object.');
    }
  }

  var schema = new Schema(blueprint);

  if (options.name) {
    schema.setName(options.name);
  }

  if (options.file) {
    schema.setFile(options.file);
  }

  if (options.unknown) {
    schema.allowUnknown();
  }

  return schema.build(struct, options.prefix);
}

var CollectionPredicate = function (_Predicate) {
  _inheritsLoose(CollectionPredicate, _Predicate);

  function CollectionPredicate() {
    return _Predicate.apply(this, arguments) || this;
  }

  var _proto = CollectionPredicate.prototype;

  _proto.sizeOf = function sizeOf(length) {
    var _this = this;

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(typeof length === 'number' && length > 0, 'Size requires a non-zero positive number.');
      this.addCheck(function (path, value) {
        if (_this.isNullable && value === null) {
          return;
        }

        if (Array.isArray(value)) {
          _this.invariant(value.length === length, "Array length must be " + length + ".", path);
        } else if (typeof value === 'string') {
          _this.invariant(value.length === length, "String length must be " + length + ".", path);
        } else if (typeof value === 'object' && value) {
          _this.invariant(Object.keys(value).length === length, "Object must have " + length + " properties.", path);
        } else {
          _this.invariant(false, 'Unknown type for size of checks.', path);
        }
      });
    }

    return this;
  };

  return CollectionPredicate;
}(Predicate);

var ArrayPredicate = function (_CollectionPredicate) {
  _inheritsLoose(ArrayPredicate, _CollectionPredicate);

  function ArrayPredicate(contents, defaultValue) {
    var _this;

    if (contents === void 0) {
      contents = null;
    }

    if (defaultValue === void 0) {
      defaultValue = [];
    }

    _this = _CollectionPredicate.call(this, 'array', defaultValue) || this;

    _defineProperty(_assertThisInitialized(_this), "contents", null);

    _this.contents = contents;

    if (contents instanceof Predicate) {
      _this.addCheck(function (path, value) {
        var nextValue = [].concat(value);
        value.forEach(function (item, i) {
          nextValue[i] = contents.run(item, path + "[" + i + "]", _this.schema);
        });
        return nextValue;
      });
    } else if ("production" !== process.env.NODE_ENV && contents) {
      _this.invariant(false, 'A blueprint is required for array contents.');
    }

    return _this;
  }

  var _proto = ArrayPredicate.prototype;

  _proto.cast = function cast(value) {
    if (value === undefined) {
      return [];
    }

    return Array.isArray(value) ? value : [value];
  };

  _proto.notEmpty = function notEmpty() {
    var _this2 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        if (_this2.isNullable && value === null) {
          return;
        }

        _this2.invariant(value.length > 0, 'Array cannot be empty.', path);
      });
    }

    return this;
  };

  _proto.typeAlias = function typeAlias() {
    var contents = this.contents;

    var alias = _CollectionPredicate.prototype.typeAlias.call(this);

    return contents ? alias + "<" + contents.typeAlias() + ">" : alias;
  };

  return ArrayPredicate;
}(CollectionPredicate);
function array(contents, defaultValue) {
  if (contents === void 0) {
    contents = null;
  }

  return new ArrayPredicate(contents, defaultValue);
}

var BooleanPredicate = function (_Predicate) {
  _inheritsLoose(BooleanPredicate, _Predicate);

  function BooleanPredicate(defaultValue) {
    return _Predicate.call(this, 'boolean', defaultValue) || this;
  }

  var _proto = BooleanPredicate.prototype;

  _proto.cast = function cast(value) {
    return Boolean(value);
  };

  _proto.onlyFalse = function onlyFalse() {
    var _this = this;

    this.defaultValue = false;
    this.defaultValueFactory = undefined;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        _this.invariant(value === false, 'May only be `false`.', path);
      });
    }

    return this;
  };

  _proto.onlyTrue = function onlyTrue() {
    var _this2 = this;

    this.defaultValue = true;
    this.defaultValueFactory = undefined;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        _this2.invariant(value === true, 'May only be `true`.', path);
      });
    }

    return this;
  };

  return BooleanPredicate;
}(Predicate);
function bool(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = false;
  }

  return new BooleanPredicate(defaultValue);
}

function instanceOf(object, contract) {
  if (!object || typeof object !== 'object') {
    return false;
  }

  if (object instanceof contract) {
    return true;
  }

  var current = object;

  while (current) {
    if (current.constructor.name === 'Object') {
      return false;
    }

    if (current.constructor.name === contract.name || current instanceof Error && current.name === contract.name) {
      return true;
    }

    current = Object.getPrototypeOf(current);
  }

  return false;
}

var InstancePredicate = function (_Predicate) {
  _inheritsLoose(InstancePredicate, _Predicate);

  function InstancePredicate(refClass, loose) {
    var _this;

    if (refClass === void 0) {
      refClass = null;
    }

    if (loose === void 0) {
      loose = false;
    }

    _this = _Predicate.call(this, 'instance', null) || this;

    _defineProperty(_assertThisInitialized(_this), "loose", false);

    _defineProperty(_assertThisInitialized(_this), "refClass", null);

    _this.nullable();

    if ("production" !== process.env.NODE_ENV) {
      if (refClass) {
        _this.invariant(typeof refClass === 'function', 'A class reference is required.');
      }

      _this.loose = loose;
      _this.refClass = refClass;

      _this.addCheck(function (path, value) {
        if (refClass) {
          _this.invariant(typeof refClass === 'function' && (value instanceof refClass || _this.loose && isObject(value) && instanceOf(value, refClass)), "Must be an instance of \"" + _this.typeAlias() + "\".", path);
        } else {
          _this.invariant(isObject(value) && value.constructor !== Object, 'Must be a class instance.', path);
        }
      });
    }

    return _this;
  }

  var _proto = InstancePredicate.prototype;

  _proto.typeAlias = function typeAlias() {
    var refClass = this.refClass;
    return refClass ? refClass.name || refClass.constructor.name : 'class';
  };

  return InstancePredicate;
}(Predicate);
function instance(refClass, loose) {
  if (refClass === void 0) {
    refClass = null;
  }

  return new InstancePredicate(refClass, loose);
}
function predicate() {
  return instance(Predicate);
}
function regex() {
  return instance(RegExp);
}
function date() {
  return instance(Date);
}

function isNumber(value) {
  return typeof value === 'number' && !Number.isNaN(value);
}

var NumberPredicate = function (_Predicate) {
  _inheritsLoose(NumberPredicate, _Predicate);

  function NumberPredicate(defaultValue) {
    return _Predicate.call(this, 'number', defaultValue) || this;
  }

  var _proto = NumberPredicate.prototype;

  _proto.between = function between(min, max, inclusive) {
    var _this = this;

    if (inclusive === void 0) {
      inclusive = false;
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(isNumber(min) && isNumber(max), 'Between requires a minimum and maximum number.');
      this.addCheck(function (path, value) {
        _this.invariant(isNumber(value) && (inclusive ? value >= min && value <= max : value > min && value < max), "Number must be between " + min + " and " + max + (inclusive ? ' inclusive' : '') + ".", path);
      });
    }

    return this;
  };

  _proto.cast = function cast(value) {
    return value === undefined ? 0 : Number(value);
  };

  _proto.float = function float() {
    var _this2 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        _this2.invariant(isNumber(value) && value % 1 !== 0, 'Number must be a float.', path);
      });
    }

    return this;
  };

  _proto.gt = function gt(min, inclusive) {
    var _this3 = this;

    if (inclusive === void 0) {
      inclusive = false;
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(isNumber(min), 'Greater-than requires a minimum number.');
      this.addCheck(function (path, value) {
        if (inclusive) {
          _this3.invariant(isNumber(value) && value >= min, "Number must be greater than or equal to " + min + ".", path);
        } else {
          _this3.invariant(isNumber(value) && value > min, "Number must be greater than " + min + ".", path);
        }
      });
    }

    return this;
  };

  _proto.gte = function gte(min) {
    return this.gt(min, true);
  };

  _proto.int = function int() {
    var _this4 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        _this4.invariant(Number.isSafeInteger(value), 'Number must be an integer.', path);
      });
    }

    return this;
  };

  _proto.lt = function lt(max, inclusive) {
    var _this5 = this;

    if (inclusive === void 0) {
      inclusive = false;
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(isNumber(max), 'Less-than requires a maximum number.');
      this.addCheck(function (path, value) {
        if (inclusive) {
          _this5.invariant(isNumber(value) && value <= max, "Number must be less than or equal to " + max + ".", path);
        } else {
          _this5.invariant(isNumber(value) && value < max, "Number must be less than " + max + ".", path);
        }
      });
    }

    return this;
  };

  _proto.lte = function lte(max) {
    return this.lt(max, true);
  };

  _proto.negative = function negative() {
    var _this6 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        _this6.invariant(isNumber(value) && value < 0, 'Number must be negative.', path);
      });
    }

    return this;
  };

  _proto.oneOf = function oneOf(list) {
    var _this7 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(Array.isArray(list) && list.length > 0 && list.every(function (item) {
        return isNumber(item);
      }), 'One of requires a non-empty array of numbers.');
      this.addCheck(function (path, value) {
        _this7.invariant(list.includes(value), "Number must be one of: " + list.join(', '), path);
      });
    }

    return this;
  };

  _proto.positive = function positive() {
    var _this8 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        _this8.invariant(isNumber(value) && value > 0, 'Number must be positive.', path);
      });
    }

    return this;
  };

  return NumberPredicate;
}(Predicate);
function number(defaultValue) {
  return new NumberPredicate(defaultValue);
}

var ObjectPredicate = function (_CollectionPredicate) {
  _inheritsLoose(ObjectPredicate, _CollectionPredicate);

  function ObjectPredicate(contents, defaultValue) {
    var _this;

    if (contents === void 0) {
      contents = null;
    }

    _this = _CollectionPredicate.call(this, 'object', defaultValue) || this;

    _defineProperty(_assertThisInitialized(_this), "contents", null);

    _this.contents = contents;

    if (contents instanceof Predicate) {
      _this.addCheck(function (path, value) {
        var nextValue = _extends({}, value);

        Object.keys(value).forEach(function (baseKey) {
          var key = baseKey;
          nextValue[key] = contents.run(value[key], path + "." + key, _this.schema);
        });
        return nextValue;
      });
    } else if ("production" !== process.env.NODE_ENV && contents) {
      _this.invariant(false, 'A blueprint is required for object contents.');
    }

    return _this;
  }

  var _proto = ObjectPredicate.prototype;

  _proto.cast = function cast(value) {
    var obj = isObject(value) ? value : {};
    return obj;
  };

  _proto.notEmpty = function notEmpty() {
    var _this2 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        if (_this2.isNullable && value === null) {
          return;
        }

        _this2.invariant(Object.keys(value).length > 0, 'Object cannot be empty.', path);
      });
    }

    return this;
  };

  _proto.typeAlias = function typeAlias() {
    var contents = this.contents;

    var alias = _CollectionPredicate.prototype.typeAlias.call(this);

    return contents ? alias + "<" + contents.typeAlias() + ">" : alias;
  };

  return ObjectPredicate;
}(CollectionPredicate);
function object(contents, defaultValue) {
  if (contents === void 0) {
    contents = null;
  }

  return new ObjectPredicate(contents, defaultValue);
}
function blueprint(defaultValue) {
  return new ObjectPredicate(predicate().notNullable(), defaultValue);
}

var ShapePredicate = function (_Predicate) {
  _inheritsLoose(ShapePredicate, _Predicate);

  function ShapePredicate(contents) {
    var _this;

    _this = _Predicate.call(this, 'shape', {}) || this;

    _defineProperty(_assertThisInitialized(_this), "contents", void 0);

    _defineProperty(_assertThisInitialized(_this), "isExact", false);

    if ("production" !== process.env.NODE_ENV) {
      _this.invariant(isObject(contents) && Object.keys(contents).length > 0 && Object.values(contents).every(function (content) {
        return content instanceof Predicate;
      }), 'A non-empty object of properties to blueprints are required for a shape.');
    }

    _this.contents = contents;
    return _this;
  }

  var _proto = ShapePredicate.prototype;

  _proto.default = function _default() {
    var _this2 = this;

    var struct = {};
    Object.keys(this.contents).forEach(function (baseKey) {
      var key = baseKey;
      struct[key] = _this2.contents[key].default();
    });
    return struct;
  };

  _proto.exact = function exact() {
    this.isExact = true;
    return this;
  };

  _proto.doRun = function doRun(value, path) {
    var _this$schema,
        _this$schema2,
        _this3 = this;

    if ("production" !== process.env.NODE_ENV && value) {
      this.invariant(isObject(value), 'Value passed to shape must be an object.', path);
    }

    var unknownFields = _extends({}, value);

    var struct = _extends({}, value);

    var oldPath = (_this$schema = this.schema) === null || _this$schema === void 0 ? void 0 : _this$schema.parentPath;
    var oldStruct = (_this$schema2 = this.schema) === null || _this$schema2 === void 0 ? void 0 : _this$schema2.parentStruct;
    this.schema.parentPath = path;
    this.schema.parentStruct = struct;
    Object.keys(this.contents).forEach(function (baseKey) {
      var key = baseKey;
      var content = _this3.contents[key];
      struct[key] = content.run(value === null || value === void 0 ? void 0 : value[key], path + "." + key, _this3.schema);
      delete unknownFields[key];
    });

    if (this.isExact) {
      if ("production" !== process.env.NODE_ENV) {
        logUnknown(unknownFields, path);
      }
    } else {
      Object.assign(struct, unknownFields);
    }

    this.schema.parentPath = oldPath;
    this.schema.parentStruct = oldStruct;
    return struct;
  };

  return ShapePredicate;
}(Predicate);
function shape(contents) {
  return new ShapePredicate(contents);
}

function isString(value) {
  return typeof value === 'string' && value !== '';
}

var StringPredicate = function (_CollectionPredicate) {
  _inheritsLoose(StringPredicate, _CollectionPredicate);

  function StringPredicate(defaultValue) {
    return _CollectionPredicate.call(this, 'string', defaultValue) || this;
  }

  var _proto = StringPredicate.prototype;

  _proto.camelCase = function camelCase() {
    return this.match(/^[a-z][0-9A-Za-z]+$/, 'String must be in camel case.');
  };

  _proto.cast = function cast(value) {
    return value === undefined ? '' : String(value);
  };

  _proto.contains = function contains(token, index) {
    var _this = this;

    if (index === void 0) {
      index = 0;
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(isString(token), 'Contains requires a non-empty token.');
      this.addCheck(function (path, value) {
        if (_this.isOptionalDefault(value)) {
          return;
        }

        _this.invariant(value.includes(token, index), "String does not include \"" + token + "\".", path);
      });
    }

    return this;
  };

  _proto.kebabCase = function kebabCase() {
    return this.match(/^[a-z][\x2D0-9a-z]+$/, 'String must be in kebab case.');
  };

  _proto.lowerCase = function lowerCase() {
    var _this2 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        _this2.invariant(value === value.toLocaleLowerCase(), 'String must be lower cased.', path);
      });
    }

    return this;
  };

  _proto.match = function match(pattern, message) {
    var _this3 = this;

    if (message === void 0) {
      message = '';
    }

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(pattern instanceof RegExp, 'Match requires a regular expression to match against.');
      this.addCheck(function (path, value) {
        if (_this3.isOptionalDefault(value)) {
          return;
        }

        _this3.invariant(!!value.match(pattern), (message || 'String does not match.') + " (pattern \"" + pattern.source + "\")", path);
      });
    }

    return this;
  };

  _proto.notEmpty = function notEmpty() {
    var _this4 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        if (_this4.isNullable && value === null) {
          return;
        }

        _this4.invariant(isString(value), 'String cannot be empty.', path);
      });
    }

    return this;
  };

  _proto.oneOf = function oneOf(list) {
    var _this5 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.invariant(Array.isArray(list) && list.length > 0 && list.every(function (item) {
        return isString(item);
      }), 'One of requires a non-empty array of strings.');
      this.addCheck(function (path, value) {
        _this5.invariant(list.includes(value), "String must be one of: " + list.join(', '), path);
      });
    }

    return this;
  };

  _proto.pascalCase = function pascalCase() {
    return this.match(/^[A-Z][0-9A-Za-z]+$/, 'String must be in pascal case.');
  };

  _proto.snakeCase = function snakeCase() {
    return this.match(/^[a-z][0-9_a-z]+$/, 'String must be in snake case.');
  };

  _proto.upperCase = function upperCase() {
    var _this6 = this;

    if ("production" !== process.env.NODE_ENV) {
      this.addCheck(function (path, value) {
        _this6.invariant(value === value.toLocaleUpperCase(), 'String must be upper cased.', path);
      });
    }

    return this;
  };

  return StringPredicate;
}(CollectionPredicate);
function string(defaultValue) {
  return new StringPredicate(defaultValue);
}

var TuplePredicate = function (_Predicate) {
  _inheritsLoose(TuplePredicate, _Predicate);

  function TuplePredicate(contents) {
    var _this;

    _this = _Predicate.call(this, 'tuple', []) || this;

    _defineProperty(_assertThisInitialized(_this), "contents", void 0);

    if ("production" !== process.env.NODE_ENV) {
      _this.invariant(Array.isArray(contents) && contents.length > 0 && contents.every(function (content) {
        return content instanceof Predicate;
      }), 'A non-empty array of blueprints are required for a tuple.');
    }

    _this.contents = contents;
    return _this;
  }

  var _proto = TuplePredicate.prototype;

  _proto.default = function _default() {
    return this.contents.map(function (content) {
      return content.default();
    });
  };

  _proto.typeAlias = function typeAlias() {
    return "[" + this.contents.map(function (item) {
      return item.typeAlias();
    }).join(', ') + "]";
  };

  _proto.doRun = function doRun(value, path) {
    var _this2 = this;

    if ("production" !== process.env.NODE_ENV) {
      if (value) {
        this.invariant(Array.isArray(value) && value.length <= this.contents.length, "Value must be a tuple with less than or equal to " + this.contents.length + " items.");
      }
    }

    var nextValue = value ? [].concat(value) : [];
    this.contents.forEach(function (content, i) {
      nextValue[i] = content.run(nextValue[i], path + "[" + i + "]", _this2.schema);
    });
    return nextValue;
  };

  return TuplePredicate;
}(Predicate);
function tuple(contents) {
  return new TuplePredicate(contents);
}

var UnionPredicate = function (_Predicate) {
  _inheritsLoose(UnionPredicate, _Predicate);

  function UnionPredicate(contents, defaultValue) {
    var _this;

    _this = _Predicate.call(this, 'union', defaultValue) || this;

    _defineProperty(_assertThisInitialized(_this), "contents", []);

    if ("production" !== process.env.NODE_ENV) {
      _this.invariant(Array.isArray(contents) && contents.length > 0 && contents.every(function (content) {
        return content instanceof Predicate;
      }), 'A non-empty array of blueprints are required for a union.');

      _this.addCheck(_this.checkUnions);
    }

    _this.contents = contents;
    return _this;
  }

  var _proto = UnionPredicate.prototype;

  _proto.typeAlias = function typeAlias() {
    return this.contents.map(function (content) {
      return content.typeAlias();
    }).join(' | ');
  };

  _proto.checkUnions = function checkUnions(path, value) {
    var _this2 = this;

    var nextValue = value;

    if ("production" !== process.env.NODE_ENV) {
      var contents = this.contents;
      var keys = contents.map(function (content) {
        return content.typeAlias();
      }).join(', ');
      var type = typeOf(value);
      var errors = new Set();
      var passed = contents.some(function (content) {
        if (content.type === 'union') {
          _this2.invariant(false, 'Nested unions are not supported.', path);
        }

        try {
          if (type === content.type || type === 'object' && content.type === 'shape' || type === 'array' && content.type === 'tuple' || content.type === 'custom') {
            content.noErrorPrefix = true;
            nextValue = content.run(value, path, _this2.schema);
            return true;
          }

          return false;
        } catch (error) {
          errors.add(" - " + error.message + "\n");
        }

        return false;
      });
      var message = "Type must be one of: " + keys + ".";

      if (!passed && errors.size > 0) {
        message += " Received " + type + " with the following invalidations:\n";
        errors.forEach(function (error) {
          message += error;
        });
      }

      this.invariant(passed, message.trim(), path);
    }

    return nextValue;
  };

  return UnionPredicate;
}(Predicate);
function union(contents, defaultValue) {
  return new UnionPredicate(contents, defaultValue);
}

/**
 * @copyright   2017-2019, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var predicates = {
  array: array,
  blueprint: blueprint,
  bool: bool,
  custom: custom,
  date: date,
  func: func,
  instance: instance,
  number: number,
  object: object,
  predicate: predicate,
  regex: regex,
  shape: shape,
  string: string,
  tuple: tuple,
  union: union
};

exports.ArrayPredicate = ArrayPredicate;
exports.BooleanPredicate = BooleanPredicate;
exports.InstancePredicate = InstancePredicate;
exports.NumberPredicate = NumberPredicate;
exports.ObjectPredicate = ObjectPredicate;
exports.Predicate = Predicate;
exports.Schema = Schema;
exports.ShapePredicate = ShapePredicate;
exports.StringPredicate = StringPredicate;
exports.TuplePredicate = TuplePredicate;
exports.UnionPredicate = UnionPredicate;
exports.array = array;
exports.blueprint = blueprint;
exports.bool = bool;
exports.custom = custom;
exports.date = date;
exports.default = optimal;
exports.func = func;
exports.instance = instance;
exports.number = number;
exports.object = object;
exports.predicate = predicate;
exports.predicates = predicates;
exports.regex = regex;
exports.shape = shape;
exports.string = string;
exports.tuple = tuple;
exports.union = union;
