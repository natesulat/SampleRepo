import { Blueprint, Predicates } from 'optimal';
import { Optionable } from './types';
export default abstract class Contract<T extends object = {}> implements Optionable<T> {
    readonly options: Readonly<Required<T>>;
    constructor(options?: T);
    /**
     * Set an options object by merging the new partial and existing options
     * with the defined blueprint, while running all validation checks.
     * Freeze and return the options object.
     */
    configure(options?: Partial<T> | ((options: Required<T>) => Partial<T>)): Readonly<Required<T>>;
    /**
     * Define an optimal blueprint in which to validate and build the
     * options object passed to the constructor, or when manual setting.
     */
    abstract blueprint(predicates: Predicates): Blueprint<T>;
}
//# sourceMappingURL=Contract.d.ts.map