import Schema from './Schema';
import { SupportedType, CheckerCallback, CustomCallback, FuncOf, DefaultValue, DefaultValueFactory, NonUndefined } from './types';
export interface TemporalStruct {
    [key: string]: unknown;
}
export default class Predicate<T> {
    defaultValue?: T | null;
    schema?: Schema<{}>;
    type: SupportedType;
    protected checks: CheckerCallback[];
    protected defaultValueFactory?: DefaultValueFactory<T>;
    protected deprecatedMessage: string;
    protected errorMessage: string;
    protected isNever: boolean;
    protected isNullable: boolean;
    protected isRequired: boolean;
    protected noErrorPrefix: boolean;
    constructor(type: SupportedType, defaultValue?: DefaultValue<T>, bypassFactory?: boolean);
    /**
     * Map a list of names that must be defined alongside this field.
     */
    and(...keys: string[]): this;
    /**
     * Cast the value if need be.
     */
    cast(value: unknown): T;
    /**
     * Set a callback to run custom logic.
     */
    custom<S extends object = object>(callback: CustomCallback<T, S>): this;
    /**
     * Return the default value for the current instance.
     */
    default(): T | null;
    /**
     * Set a message to log when this field is present.
     */
    deprecate(message: string): this;
    /**
     * Throw an error if the condition is falsy.
     */
    invariant(condition: boolean, message: string, path?: string): void;
    /**
     * Set a custom error message for all checks.
     */
    message(message: string): this;
    /**
     * Field should never be used.
     */
    never(): Predicate<never>;
    /**
     * Disallow null values.
     */
    notNullable(): Predicate<NonNullable<T>>;
    /**
     * Allow null values.
     */
    nullable(): Predicate<T | null>;
    /**
     * Mark a field as only the default value can be used.
     */
    only(): this;
    /**
     * Map a list of field names that must have at least 1 defined.
     */
    or(...keys: string[]): this;
    /**
     * Require an object property to be explicitly defined.
     */
    required(state?: boolean): this;
    /**
     * Run all validation checks that have been enqueued and return a type casted value.
     * If a value is undefined, inherit the default value, else throw if required.
     * If nullable and the value is null, return early.
     */
    run(initialValue: T | undefined, path: string, schema: Schema<{}>): NonUndefined<T> | null;
    /**
     * Return a human readable type name.
     */
    typeAlias(): string;
    /**
     * Validate the passed value and return it.
     * Will not inherit default value if undefined.
     */
    validate(value: T, path?: string): T;
    /**
     * Map a list of field names that must not be defined alongside this field.
     */
    xor(...keys: string[]): this;
    /**
     * Add a checking function with optional arguments.
     */
    protected addCheck(checker: CheckerCallback<T>): this;
    /**
     * Validate the type of value.
     */
    protected checkType(path: string, value: T): void;
    /**
     * Return true if the value matches the default value and the predicate is optional.
     */
    protected isOptionalDefault(value: unknown): boolean;
    /**
     * Return the current key from a path.
     */
    protected key(path: string): string;
    /**
     * Helper method for sub-classes to provide custom run logic.
     */
    protected doRun(value: T, path: string): T;
}
export declare function custom<T, S extends object = {}>(callback: CustomCallback<T, S>, defaultValue: DefaultValue<T>): Predicate<T>;
export declare function func<T = FuncOf>(defaultValue?: T | null): Predicate<T | null>;
