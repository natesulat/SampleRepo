"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@boost/common");
const internal_1 = require("@boost/internal");
const EXTS = {
    js: ['js'],
    json: ['json', 'json5'],
    yaml: ['yaml', 'yml'],
};
class FileBackend extends common_1.Contract {
    constructor() {
        super(...arguments);
        this.fileCache = new Map();
        this.type = 'backend';
    }
    init(services, options) {
        this.configure(options);
        // Validate resource paths are directories
        this.options.paths.forEach(path => {
            if (path.exists() && !path.isDirectory()) {
                throw new internal_1.RuntimeError('translate', 'TL_INVALID_RES_PATH', [path.path()]);
            }
        });
    }
    blueprint({ array, instance, string }) {
        return {
            format: string('yaml').oneOf(['js', 'json', 'yaml']),
            paths: array(instance(common_1.Path, true).notNullable()),
        };
    }
    // istanbul ignore next
    create() {
        // We don't need this but is required by the interface
    }
    read(locale, namespace, callback) {
        const { format, paths } = this.options;
        const resources = {};
        paths.forEach(path => {
            EXTS[format].some(ext => {
                const resPath = path.append(locale, `${namespace}.${ext}`);
                const isCached = this.fileCache.has(resPath);
                if (!resPath.exists()) {
                    return false;
                }
                if (!isCached) {
                    this.fileCache.set(resPath, common_1.parseFile(resPath));
                }
                Object.assign(resources, this.fileCache.get(resPath));
                return true;
            });
        });
        callback(null, resources);
        return resources;
    }
}
exports.default = FileBackend;
