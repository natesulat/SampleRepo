"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
class Path {
    constructor(...parts) {
        this.internalPath = '';
        this.stats = null;
        // Always use forward slashes for better interop
        this.internalPath = path_1.default.normalize(path_1.default.join(...parts.map(String))).replace(/\\/gu, Path.SEP);
    }
    /**
     * Create and return a new `Path` instance if a string.
     * If already a `Path`, return as is.
     */
    static create(filePath) {
        return filePath instanceof Path ? filePath : new Path(filePath);
    }
    /**
     * Like `create()` but also resolves the path against CWD.
     */
    static resolve(filePath, cwd) {
        return Path.create(filePath).resolve(cwd);
    }
    /**
     * Append path parts to the end of the current path
     * and return a new `Path` instance.
     */
    append(...parts) {
        return new Path(this.internalPath, ...parts);
    }
    /**
     * Returns true if both paths are equal using strict equality.
     */
    equals(filePath) {
        return this.path() === Path.create(filePath).path();
    }
    /**
     * Return the extension (if applicable) with or without leading period.
     */
    ext(withoutPeriod = false) {
        const ext = path_1.default.extname(this.internalPath);
        return withoutPeriod && ext.startsWith('.') ? ext.slice(1) : ext;
    }
    /**
     * Return true if the current path exists.
     */
    exists() {
        return fs_1.default.existsSync(this.internalPath);
    }
    /**
     * Return true if the current path is absolute.
     */
    isAbsolute() {
        return path_1.default.isAbsolute(this.internalPath);
    }
    /**
     * Return true if the current path is a folder.
     */
    isDirectory() {
        return this.stat().isDirectory();
    }
    /**
     * Return true if the current path is a file.
     */
    isFile() {
        return this.stat().isFile();
    }
    /**
     * Return the file name (with optional extension) or folder name.
     */
    name(withoutExtension = false) {
        let name = path_1.default.basename(this.internalPath);
        if (withoutExtension) {
            name = name.replace(this.ext(), '');
        }
        return name;
    }
    /**
     * Return the parent folder as a new `Path` instance.
     */
    parent() {
        return new Path(path_1.default.dirname(this.internalPath));
    }
    /**
     * Return the current path as a normalized string.
     */
    path() {
        return this.internalPath;
    }
    /**
     * Prepend path parts to the beginning of the current path
     * and return a new `Path` instance.
     */
    prepend(...parts) {
        return new Path(...parts, this.internalPath);
    }
    /**
     * Returns a canonical path by resolving directories and symlinks.
     */
    // istanbul ignore next
    realPath() {
        const filePath = this.path();
        if (typeof fs_1.default.realpathSync.native === 'function') {
            try {
                return fs_1.default.realpathSync.native(filePath);
            }
            catch (_a) {
                // Skip
            }
        }
        // @ts-ignore
        const fsBinding = process.binding('fs');
        if (fsBinding.realpath) {
            try {
                return fsBinding.realpath(filePath, 'utf8');
            }
            catch (_b) {
                // Skip
            }
        }
        return fs_1.default.realpathSync(filePath);
    }
    /**
     * Return a new relative `Path` instance from the current
     * "from" path to the defined "to" path.
     */
    relativeTo(to) {
        return new Path(path_1.default.relative(this.path(), String(to)));
    }
    /**
     * Return a new `Path` instance where the current path is accurately
     * resolved against the defined current working directory.
     */
    resolve(cwd) {
        return new Path(path_1.default.resolve(String(cwd || process.cwd()), this.internalPath));
    }
    toJSON() {
        return this.path();
    }
    toString() {
        return this.path();
    }
    stat() {
        if (!this.stats) {
            this.stats = fs_1.default.statSync(this.internalPath);
        }
        return this.stats;
    }
}
exports.default = Path;
Path.DELIMITER = path_1.default.delimiter;
Path.SEP = '/';
