"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const internal_1 = require("@boost/internal");
const types_1 = require("./types");
const Path_1 = __importDefault(require("./Path"));
class PathResolver {
    constructor() {
        this.lookups = [];
    }
    /**
     * Return a list of all lookup paths.
     */
    getLookupPaths() {
        return this.lookups.map(lookup => lookup.path.path());
    }
    /**
     * Add a file system path to look for, resolved against the defined current
     * working directory (or `process.cwd()` otherwise).
     */
    lookupFilePath(filePath, cwd) {
        this.lookups.push({
            path: Path_1.default.resolve(filePath, cwd),
            raw: Path_1.default.create(filePath),
            type: types_1.LookupType.FILE_SYSTEM,
        });
        return this;
    }
    /**
     * Add a Node.js module, either by name or relative path, to look for.
     */
    lookupNodeModule(modulePath) {
        const path = Path_1.default.create(modulePath);
        this.lookups.push({
            path,
            raw: path,
            type: types_1.LookupType.NODE_MODULE,
        });
        return this;
    }
    /**
     * Given a list of lookups, attempt to find the first real/existing path and
     * return a resolved absolute path. If a file system path, will check using `fs.exists`.
     * If a node module path, will check using `require.resolve`.
     */
    resolve() {
        let resolvedPath = '';
        let resolvedLookup;
        this.lookups.some(lookup => {
            // Check that the file exists on the file system.
            if (lookup.type === types_1.LookupType.FILE_SYSTEM) {
                if (lookup.path.exists()) {
                    resolvedPath = lookup.path;
                    resolvedLookup = lookup;
                }
                else {
                    return false;
                }
                // Check that the module path exists using Node's module resolution.
                // The `require.resolve` function will throw an error if not found.
            }
            else if (lookup.type === types_1.LookupType.NODE_MODULE) {
                try {
                    resolvedPath = require.resolve(lookup.path.path());
                    resolvedLookup = lookup;
                }
                catch (error) {
                    return false;
                }
            }
            return true;
        });
        if (!resolvedPath || !resolvedLookup) {
            throw new internal_1.RuntimeError('common', 'CM_PATH_RESOLVE_LOOKUPS', [
                this.lookups.map(lookup => `  - ${lookup.path} (${lookup.type})`).join('\n'),
            ]);
        }
        return {
            originalPath: resolvedLookup.raw,
            resolvedPath: Path_1.default.create(resolvedPath),
            type: resolvedLookup.type,
        };
    }
    /**
     * Like `resolve()` but only returns the resolved path.
     */
    resolvePath() {
        return this.resolve().resolvedPath;
    }
}
exports.default = PathResolver;
